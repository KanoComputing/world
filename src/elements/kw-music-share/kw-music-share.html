<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">

<!--


    @demo demo/index.html
-->
<dom-module id="kw-music-share">
    <template>
        <style>
            :host {
                background: #58d6fa;
                @apply --layout-vertical;
                @apply --layout-center-justified;
                color: white;
                padding: 16px;
            }
            .player {
                @apply --layout-horizontal;
                @apply --layout-center;
            }
            .player .spectrum {
                flex: 1 0 auto;
                margin-left: 16px;
            }
            .playback-time {
                margin-left: 16px;
            }
            .playback-button {
                border-radius: 50%;
                border: 5px solid white;
                width: 30px;
                height: 30px;
                background: transparent;
            }
        </style>
        <div class="player">
            <button type="button" class="playback-button" on-tap="_playbackButtonTapped">p</button>
            <div id="spectrum-container" class="spectrum">
                <canvas id="canvas"></canvas>
            </div>
            <span class="playback-time">[[_formatTime(playbackTime)]]</span>
        </div>
    </template>
    <script>
        Polymer({
            is: 'kw-music-share',
            properties: {
                share: {
                    type: Object,
                    observer: '_shareChanged'
                }
            },
            attached () {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    window.OfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
                    this.context = new AudioContext();
                } catch (e) {
                    this.cannotRenderSample = true;
                }
                this._onPlaybackEnded = this._onPlaybackEnded.bind(this);
            },
            _formatTime (duration) {
                let min = Math.floor(duration / 60),
                    sec = Math.floor(duration % 60);
                return `${min}:${sec < 10 ? '0' + sec : sec}`;
            },
            _fitCanvas () {
                let rect = this.$['spectrum-container'].getBoundingClientRect();
                this.$.canvas.width = rect.width;
                this.$.canvas.height = rect.height;
                this._canvasFitted = true;
            },
            _play () {
                if (this.cannotRenderSample || !this.buffer) {
                    return;
                }
                this.source = this.context.createBufferSource();
                this.source.buffer = this.buffer;
                this.source.connect(this.context.destination);

                this.source.addEventListener('ended', this._onPlaybackEnded);

                if (this._playbackPosition) {
                    this.source.start(0, this._playbackPosition);
                    this._startedAt = this.context.currentTime - this._playbackPosition;
                } else {
                    this.source.start(0)
                    this._startedAt = this.context.currentTime;
                }
                this._playbackStatus = 'playing';
                this._render();
            },
            _pause () {
                this._playbackPosition = this.context.currentTime - this._startedAt;
                this.source.removeEventListener('ended', this._onPlaybackEnded);
                this.source.stop();
                this._playbackStatus = 'stopped';
                this._stopRendering();
            },
            _onPlaybackEnded () {
                this._playbackPosition = 0;
                this._playbackStatus = 'stopped';
                this._stopRendering();
            },
            _playbackButtonTapped () {
                if (this._playbackStatus === 'playing') {
                    this._pause();
                } else {
                    this._play();
                }
            },
            _updatePlaybackTime () {
                let position = this._startedAt ? this.context.currentTime - this._startedAt : 0;
                this.playbackTime = this.buffer.duration - position;
            },
            _shareChanged (share) {
                let sampleUrl;

                if (!share) {
                    return;
                }

                sampleUrl = share.sample_url;

                if (!sampleUrl) {
                    this.cannotRenderSample = true;
                }
                // That might have been set by the audio context checking
                if (this.cannotRenderSample) {
                    return;
                }
                fetch(sampleUrl)
                    .then(r => r.arrayBuffer())
                    .then(ab => {
                        this.context.decodeAudioData(ab, (buffer) => {
                            this.buffer = buffer;
                            this._playbackPosition = 0;
                            this._updatePlaybackTime();
                            this._render(true);
                        });
                    });           
            },
            _render (once) {
                let ctx = this.$.canvas.getContext('2d'),
                    playbackTime,
                    playbackPosition;
                if (!this._spectrumCache) {
                    this._drawSpectrum();
                }
                if (!this._canvasFitted) {
                    this._fitCanvas();
                }
                if (!this._playbackTimeInterval) {
                    this._playbackTimeInterval = setInterval(this._updatePlaybackTime.bind(this), 1000);
                }
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.drawImage(this._spectrumCache, 0, 0, this.$.canvas.width, this.$.canvas.height);
                playbackTime = this.context.currentTime - this._startedAt;
                playbackPosition = playbackTime / this.buffer.duration;
                ctx.fillRect(playbackPosition * ctx.canvas.width, 0, 1, ctx.canvas.height);
                if (!once) {
                    this._renderId = requestAnimationFrame(this._render.bind(this, false));
                }
            },
            _stopRendering () {
                cancelAnimationFrame(this._renderId);
                clearInterval(this._playbackTimeInterval);
                this._playbackTimeInterval = null;
            },
            _drawSpectrum () {
                let data = this.buffer.getChannelData(0),
                    height = 140,
                    width = 600,
                    value, ctx;

                this._spectrumCache = document.createElement('canvas');

                this._spectrumCache.width = width;
                this._spectrumCache.height = height;

                ctx = this._spectrumCache.getContext('2d');

                ctx.fillStyle = '#58afd4';

                ctx.fillRect(0, height / 2, width, 1);

                for (let i = 0; i < width; i++) {
                    value = height / 2 * data[Math.floor(data.length / width * i)];
                    ctx.fillRect(i, height / 2 - value / 2, 1, value);
                }
            }
        });
    </script>
</dom-module>